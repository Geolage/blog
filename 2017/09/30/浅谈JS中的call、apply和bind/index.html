<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>浅谈JS中的call、apply和bind - Geolage's Blog</title><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css"><script>var GLOBAL = { 
  root: '/blog/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><link rel="icon" href="/blog/favicon.ico"></head><body><canvas class="fireworks"></canvas><i class="fa fa-bars" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#三巨头"><span class="toc-number">1.</span> <span class="toc-text">三巨头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#call"><span class="toc-number">1.1.</span> <span class="toc-text">call</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-number">1.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用"><span class="toc-number">1.1.2.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调用父构造函数，实现继承"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">调用父构造函数，实现继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调用匿名函数"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">调用匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调用函数并改变上下文的this指向"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">调用函数并改变上下文的this指向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply"><span class="toc-number">1.2.</span> <span class="toc-text">apply</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传递arguments，创建包裹函数"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">传递arguments，创建包裹函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于this"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">关于this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind"><span class="toc-number">1.3.</span> <span class="toc-text">bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绑定函数并改变this指向"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">绑定函数并改变this指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用bind-进行柯里化（currying）"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">使用bind()进行柯里化（currying）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造偏函数，使函数具有预设参数"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">构造偏函数，使函数具有预设参数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例外"><span class="toc-number">2.</span> <span class="toc-text">例外</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于-call-amp-apply"><span class="toc-number">2.1.</span> <span class="toc-text">关于 call & apply</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于bind"><span class="toc-number">2.2.</span> <span class="toc-text">关于bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于new"><span class="toc-number">2.3.</span> <span class="toc-text">关于new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于bind和new共存"><span class="toc-number">2.4.</span> <span class="toc-text">关于bind和new共存</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/blog//img/avatar.jpg"></div><div class="author-info__name text-center">Geolage Wu</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/blog/archives"><span class="pull-left">文章</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/blog/tags"><span class="pull-left">标签</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/blog/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">相关链接</div><a class="author-info-links__name text-center" href="https://www.higherloft.com" target="_blank">HigherLoft</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/blog/img/top2.jpg);"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/blog/">Geolage's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/blog/">主页</a><a class="site-page" href="/blog/archives">文章</a><a class="site-page" href="/blog/tags">标签</a><a class="site-page" href="/blog/categories">分类</a></span></div><div id="post-info"><div id="post-title">浅谈JS中的call、apply和bind</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-09-30 </time><span class="post-meta__separator"> | </span><i class="fa fa-inbox" aria-hidden="true"> </i><a class="post-meta__categories" href="/blog/categories/前端/"> 前端  </a><i class="fa fa-angle-right" aria-hidden="true"> </i><i class="fa fa-inbox" aria-hidden="true"> </i><a class="post-meta__categories" href="/blog/categories/前端/JavaScript/"> JavaScript  </a><span class="post-meta__separator"> | </span><i class="fa fa-comment-o" aria-hidden="true"> </i><a href="/blog/2017/09/30/浅谈JS中的call、apply和bind/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2017/09/30/浅谈JS中的call、apply和bind/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><p>&emsp;&emsp;关于call、apply和bind方法，网上搜出来的相关内容实在是太多，其中不免有些是纯复制粘贴的，但也有不少诚然写得不错的。我对这上述的三种方法的认识虽没有那么深刻、透彻，但博客毕竟是可以用来分享的，于是便在这里作一次小小的浅析，权当温习和巩固一下知识。<br><a id="more"></a></p>
<h1 id="三巨头"><a href="#三巨头" class="headerlink" title="三巨头"></a>三巨头</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h2><p>call方法即<strong><code>Function.prototype.call()</code></strong>，是一个能调用函数并使其具有指定的this值和分别地提供的参数(参数的列表)的方法。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func.call(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p><code>thisArg</code><br>指在fun函数运行时指定的this值。</p>
<p><code>arg1, arg2, ...</code><br>为指定的参数列表。</p>
<p><strong>返回值</strong></p>
<p>返回结果包括指定的this值和参数。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h3><h4 id="调用父构造函数，实现继承"><a href="#调用父构造函数，实现继承" class="headerlink" title="调用父构造函数，实现继承"></a>调用父构造函数，实现继承</h4><p>在一个子构造函数中，可以通过调用父构造函数的 call 方法来实现继承，类似于Java中的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,skill</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name=name;</div><div class="line">	<span class="keyword">this</span>.skill=skill;</div><div class="line">	<span class="comment">// someMethods ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ragdoll</span>(<span class="params">name,skill</span>)</span>&#123;</div><div class="line">	Cat.call(<span class="keyword">this</span>,name,skill);</div><div class="line">	<span class="keyword">this</span>.species=Ragdoll;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ragdoll=<span class="keyword">new</span> Ragdoll(<span class="string">'Kate'</span>,<span class="string">'tease'</span>);</div><div class="line"><span class="built_in">console</span>.log(ragdoll.name+<span class="string">' can '</span>+ragdoll.skill);		<span class="comment">// "Kate can tease"</span></div></pre></td></tr></table></figure>
<h4 id="调用匿名函数"><a href="#调用匿名函数" class="headerlink" title="调用匿名函数"></a>调用匿名函数</h4><p>这里我举一个比较经典的例子：延时输出一组数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(j);</div><div class="line">        &#125;,j*<span class="number">100</span>);</div><div class="line">    &#125;).call(<span class="keyword">this</span>,i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "0 1 2 3 4 5"</span></div></pre></td></tr></table></figure>
<p>在for循环体中，通过创建一个匿名函数，使用其call方法将this指向外作用域调用栈，实现参数i的调用。<br>这里还有一个例子可以更加明显地展示call的调用和this指向：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dogs = [</div><div class="line">  &#123;<span class="attr">species</span>: <span class="string">'Alaska'</span>, <span class="attr">name</span>: <span class="string">'Dodo'</span>&#125;,</div><div class="line">  &#123;<span class="attr">species</span>: <span class="string">'Golden'</span>, <span class="attr">name</span>: <span class="string">'Bobo'</span>&#125;,</div><div class="line">  <span class="comment">// someOtherData ...</span></div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dogs.length; i++) &#123;</div><div class="line">	(<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; </div><div class="line">	    <span class="keyword">this</span>.outcome = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">		    <span class="built_in">console</span>.log(<span class="string">'#'</span> + i  + <span class="string">' '</span> + <span class="keyword">this</span>.species + <span class="string">': '</span> + <span class="keyword">this</span>.name);</div><div class="line">		&#125; </div><div class="line">	    <span class="keyword">this</span>.outcome();</div><div class="line">	&#125;).call(dogs[i], i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// #0 Alaska: Dodo</span></div><div class="line"><span class="comment">// #1 Golden: Bobo</span></div></pre></td></tr></table></figure>
<h4 id="调用函数并改变上下文的this指向"><a href="#调用函数并改变上下文的this指向" class="headerlink" title="调用函数并改变上下文的this指向"></a>调用函数并改变上下文的<code>this</code>指向</h4><p>通过将某个值（对象）作为call方法的第一个参数可以使this指向上下文，之后再将参数传进实现引用。用起来比较简单，这不就是call方法需要体现的用处嘛。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">work</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.work=work;</div><div class="line">	<span class="keyword">this</span>.next();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> todo=&#123;</div><div class="line">	now:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"I'm busy!"</span>);</div><div class="line">	&#125;,</div><div class="line">	next:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"Well, I'm going to do "</span>+<span class="keyword">this</span>.work)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">doSomething.call(todo,<span class="string">'nothing'</span>);		<span class="comment">// Well, I'm going to do nothing</span></div></pre></td></tr></table></figure>
<p>p.s. 关于this的更多问题，将在下面进一步说明。</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a><strong>apply</strong></h2><p><strong><code>Function.prototype.apply()</code></strong>是一个能调用函数并使其具有一个指定的this值和一个参数数组（或类似数组的对象）的方法。</p>
<blockquote>
<p>注意：call方法的作用和 apply方法类似，它们的区别就在于，在方法体上，call方法接受的是若干个参数的<strong>参数列表</strong>，而apply方法接受的是一个包含多个参数的<strong>参数数组</strong>。</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h3><p><strong>语法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func.apply(thisArg, [argsArray])</div></pre></td></tr></table></figure></p>
<p><strong>参数</strong></p>
<p><code>thisArg</code><br>在 fun 函数运行时指定的 this 值。</p>
<p><code>argsArray</code><br>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给<code>func</code>函数。如果该参数的值为<code>null</code>或 <code>undefined</code>，则表示不需要传入任何参数。</p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a><strong>应用</strong></h3><h4 id="传递arguments，创建包裹函数"><a href="#传递arguments，创建包裹函数" class="headerlink" title="传递arguments，创建包裹函数"></a>传递arguments，创建包裹函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a,a);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a+a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">    a:<span class="number">3</span></div><div class="line">    <span class="comment">//  someOtherDara...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> foo.apply(obj,<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz=bar(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(baz);</div></pre></td></tr></table></figure>
<p>区别于call()，传入的参数必须是数组形式（[arg1,arg2…]）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">&#125;</div><div class="line">foo.apply(<span class="literal">null</span>,[<span class="number">1</span>]);		<span class="comment">// 1</span></div><div class="line">foo.apply(<span class="literal">null</span>,<span class="number">1</span>);		  <span class="comment">// TypeError: CreateListFromArrayLike called on non-object</span></div></pre></td></tr></table></figure>
<p>调用函数以及改变this指向的一些应用，跟上文的call方法基本一致，唯一不同的，则是参数是传入形式不同，前者为参数数组<strong><code>（,[args...]）</code></strong>，后者则为参数列表<strong><code>（,arg1,arg2,...）</code></strong>上面亦有提及，这里便不再赘述。</p>
<h4 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h4><p>在这里对上面在call和apply方法中所提及的this指向问题作进一步阐释：</p>
<blockquote>
<p>无论是 <u><strong>call()</strong></u>、<u><strong>apply()</strong></u>，还是下面将提到的 <u><strong>bind()</strong></u>（虽然比较特殊，会涉及“<strong>硬绑定</strong>”问题），需要注意的是，其指定的this值并非一定是该函数执行时真正的this值，这里又再次涉及到<strong>上下文（context）</strong>的概念。如果这个函数处于<strong>非严格模式</strong>下，指定为<code>null</code>和<code>undefined</code>的<strong>this</strong>在调用时会被忽略，会自动指向<strong>全局对象</strong>(也就是浏览器默认的<strong>window对象</strong>)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象；若在<strong>严格模式（”use strict”）</strong>下，<strong>this</strong>则指向<code>undefined</code>。</p>
</blockquote>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a><strong>bind</strong></h2><p><strong><code>Function.prototype.bind()</code></strong>是一个可以创建新的函数，当其被调用时可将this设置为提供的值并提供一个给定的参数序列的方法。</p>
<p>注意：bind方法只进行函数绑定，并不会在绑定后立即执行，需要跟call和apply方法区分开来。</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a><strong>概念</strong></h3><p><strong>语法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func.bind(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>
<p><strong>参数</strong><br><code>thisArg</code><br>当绑定函数被调用时，该参数会作为原函数运行时的<code>this</code>指向。<br>（<em>注意：当使用<code>new</code>操作符调用绑定函数时，该参数无效。</em>）</p>
<p><code>arg1, arg2, ...</code><br>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</p>
<p><strong>返回值</strong><br>返回由指定的<code>this</code>值和初始化参数改造的原函数拷贝。</p>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a><strong>应用</strong></h3><h4 id="绑定函数并改变this指向"><a href="#绑定函数并改变this指向" class="headerlink" title="绑定函数并改变this指向"></a>绑定函数并改变this指向</h4><p>这个应用跟上面没啥异同，看看代码就知道了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a,a);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a+a;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj=&#123;</div><div class="line">    a:<span class="number">2</span></div><div class="line">    <span class="comment">//  someOtherDara...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar=foo.bind(obj);</div><div class="line"><span class="keyword">var</span> baz=bar(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(baz);</div><div class="line"><span class="comment">//	2 3</span></div><div class="line"><span class="comment">//  5</span></div></pre></td></tr></table></figure>
<h4 id="使用bind-进行柯里化（currying）"><a href="#使用bind-进行柯里化（currying）" class="headerlink" title="使用bind()进行柯里化（currying）"></a>使用bind()进行柯里化（currying）</h4><p>在ES6之前，由于没有扩展运算符的简便应用，参数引入的操作变得尤为麻烦，用bind()来进行柯里化操作是个不错的方法。下面举个简单点的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a,b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar=foo.bind(<span class="literal">null</span>,<span class="number">2</span>);</div><div class="line">bar(<span class="number">3</span>);		<span class="comment">// currying</span></div><div class="line"><span class="comment">// 2 , 3</span></div></pre></td></tr></table></figure>
<h4 id="构造偏函数，使函数具有预设参数"><a href="#构造偏函数，使函数具有预设参数" class="headerlink" title="构造偏函数，使函数具有预设参数"></a>构造偏函数，使函数具有预设参数</h4><p>bind()另一个简单的应用是使一个函数拥有预设的初始参数。通过bind方法将参数引入，将其保存在绑定函数内。若该绑定函数在调用时插入有若干参数，则会将这些参数一并传入，插在该函数参数列表的后面，即排在bind所绑定的参数后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz=foo.bind(<span class="literal">null</span>,<span class="number">1</span>);</div><div class="line">baz();		 <span class="comment">// [1]</span></div><div class="line">baz(<span class="number">2</span>,<span class="number">3</span>)	<span class="comment">// [1，2，3]</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<blockquote>
<p>bind 函数在 <u>ECMA-262 第五版 </u>才被加入，可能无法在所有浏览器上运行。为了避免兼容性问题可能带来的困扰，有一个比较推荐的方法是采用<strong>Polyfill</strong>。你可以选择在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。</p>
</blockquote>
<p>Code:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</div><div class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></div><div class="line">      <span class="comment">// internal IsCallable function</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </div><div class="line">      fToBind = <span class="keyword">this</span>, </div><div class="line">      fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">      fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        fBound.prototype = <span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">new</span> fNOP() : fBound.prototype</div><div class="line">        <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</div><div class="line">                                 ? <span class="keyword">this</span></div><div class="line">                                 : oThis || <span class="keyword">this</span>,</div><div class="line">                                 aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">if</span>( <span class="keyword">this</span>.prototype ) &#123;</div><div class="line">      <span class="comment">// Function.prototype doesn't have a prototype property</span></div><div class="line">      fNOP.prototype = <span class="keyword">this</span>.prototype</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fBound</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="例外"><a href="#例外" class="headerlink" title="例外"></a><strong>例外</strong></h1><h2 id="关于-call-amp-apply"><a href="#关于-call-amp-apply" class="headerlink" title="关于 call &amp; apply"></a><strong>关于 call &amp; apply</strong></h2><p>首先上一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line">obj1=&#123;</div><div class="line">    a:<span class="number">2</span></div><div class="line">&#125;</div><div class="line">obj2=&#123;</div><div class="line">    a:<span class="number">3</span></div><div class="line">&#125;</div><div class="line">foo.call(obj1);</div><div class="line">foo.call(obj2);</div><div class="line">foo.apply(obj1);</div><div class="line">foo.apply(obj2);</div></pre></td></tr></table></figure>
<p>关于答案，估计你也已经知道了。没错，答案是：<code>2 3 2 3</code> 。</p>
<p>由于call和apply方法都是同种改变this指向的方法，在指定上下文后，this可以指向该对象。这对于无论是call还是apply来说，this的指向都是可以反复更改的。</p>
<h2 id="关于bind"><a href="#关于bind" class="headerlink" title="关于bind"></a><strong>关于bind</strong></h2><p>前面已经阐述了call、apply和bind的相关知识。还需指出，这三者当中，call和apply在某种意义上是一样的，只是传入的参数形式不同，而bind是一种函数绑定方法。我们应当把bind和前两者区别对待，由于bind()会涉及到“硬绑定”的问题，故在实际运用当中应当非常谨慎，不然会无故制造出一大堆麻烦。</p>
<p>这里举个简单例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line">obj1=&#123;</div><div class="line">    a:<span class="number">2</span></div><div class="line">&#125;</div><div class="line">obj2=&#123;</div><div class="line">    a:<span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar=foo.bind(obj1);</div><div class="line">bar();</div><div class="line">bar.bind(obj2)();</div><div class="line">bar.call(obj2);</div><div class="line">bar.apply(obj2);</div></pre></td></tr></table></figure>
<p>猜猜结果是怎样的？你也许会觉得，答案是：<code>2 3 3 3</code> 。</p>
<p>其实不然。结果却是：<code>2 2 2 2</code> 。为什么会这样呢？</p>
<p>还记得上面说过，bind是个绑定函数的方法，在其绑定某个函数后，this就已经指向了该函数，无论后面再使用call还是apply方法，都无法改变this的指向，故答案为“<strong>2 2 2 2</strong>”。因此，<strong>在使用bind()绑定this之前，call和apply是有效的，this可以随之更改，一旦bind()被执行，this将绑定在对应的目标函数或者对象上，且无法再次做出更改。</strong>像这种无法使用其它方法改变其this指向的问题，就是所谓的“<strong>硬绑定</strong>”问题。与之对应的，回顾上面提到的call和apply方法的应用情形，在一定程度上属于“<strong>软绑定</strong>”。</p>
<blockquote>
<p>有关“<strong>函数绑定</strong>”以及<strong><code>this</code>词法</strong>的更多内容，将在后期和大家分享。</p>
</blockquote>
<h2 id="关于new"><a href="#关于new" class="headerlink" title="关于new"></a><strong>关于new</strong></h2><p>上面提到过，当使用bind方法指定<code>this</code>时，使用<code>new</code>操作符调用绑定函数会使该参数无效。</p>
<p>来段代码试试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.a=a;</div><div class="line">&#125;</div><div class="line">obj1=&#123;</div><div class="line">    a:<span class="number">2</span></div><div class="line">&#125;</div><div class="line">obj2=&#123;</div><div class="line">    a:<span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj1.a);</div><div class="line"><span class="keyword">var</span> bar=foo.bind(obj1);</div><div class="line">bar(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(obj1.a);</div><div class="line"><span class="keyword">var</span> baz=<span class="keyword">new</span> bar(obj2.a);</div><div class="line"><span class="built_in">console</span>.log(obj1.a);</div><div class="line"><span class="built_in">console</span>.log(baz.a);</div></pre></td></tr></table></figure>
<p>再来猜猜答案吧！</p>
<p>答案是：<strong>2 1 1 3</strong> 。跟你想的一样吗？</p>
<p>由此可见，当使用new关键字时，this被指向了新创建的实例，这也就解释了为何obj1.a没有随new bar()里边的参数而改变，因为创建实例后的this是指向baz的。</p>
<h2 id="关于bind和new共存"><a href="#关于bind和new共存" class="headerlink" title="关于bind和new共存"></a><strong>关于bind和new共存</strong></h2><p>有人觉得，如果使用new来改变this指向，跟bind一同使用就显得没有必要了。</p>
<p>其实，bind和new搭配使用并不会有什么大的冲突，其未尝不是一种尚可的方法，或者更多的可以认为是一种使用风格。</p>
<p>相信你也从前面了解了，尽管使用了new去更改this指向，但是原来绑定的目标对象的值并没有随之改变。正因如此，结合两者的特点，从某种程度上我们也可以考虑利用两者搭配使用的方法进行函数柯里化处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">s1,s2</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.str=s1+s2;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.bind(<span class="literal">null</span>,<span class="string">'abc'</span>);</div><div class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="string">'def'</span>);		<span class="comment">// currying</span></div><div class="line">baz.str;	<span class="comment">// "abcdef"</span></div></pre></td></tr></table></figure>
<p>参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">Function.prototype.call()</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external">Function.prototype.apply()</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind()</a></p>
<p>参考书籍：<em>《你不知道的JavaScript（上卷）》</em></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info">Geolage Wu</span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info">https://geolage.github.io/blog/2017/09/30/浅谈JS中的call、apply和bind/</span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/Javascript/">Javascript</a><a class="post-meta__tags" href="/blog/tags/call/">call</a><a class="post-meta__tags" href="/blog/tags/apply/">apply</a><a class="post-meta__tags" href="/blog/tags/bind/">bind</a><a class="post-meta__tags" href="/blog/tags/this/">this</a><a class="post-meta__tags" href="/blog/tags/函数绑定/">函数绑定</a></div></article><nav id="pagination"><div class="next-post pull-right"><a href="/blog/2017/09/29/浅谈JS中正则表达式-RegExp-的使用/"><span>浅谈JS中正则表达式(RegExp)的使用</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'https://geolage.github.io/blog/2017/09/30/浅谈JS中的call、apply和bind/';
  this.page.identifier = '2017/09/30/浅谈JS中的call、apply和bind/';
  this.page.title = '浅谈JS中的call、apply和bind';
}
var d = document, s = d.createElement('script');
s.src = "https://geolage.disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://geolage.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">©2014 - 2017 By Geolage Wu</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/blog/js/third-party/anime.min.js"></script><script src="/blog/js/third-party/jquery.min.js"></script><script src="/blog/js/third-party/jquery.fancybox.min.js"></script><script src="/blog/js/third-party/velocity.min.js"></script><script src="/blog/js/third-party/velocity.ui.min.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/fancybox.js"></script><script src="/blog/js/sidebar.js"></script><script src="/blog/js/copy.js"></script><script src="/blog/js/fireworks.js"></script><script src="/blog/js/transition.js"></script><script src="/blog/js/scroll.js"></script><script src="/blog/js/head.js"></script><script src="/blog/js/main.js"></script></body></html>